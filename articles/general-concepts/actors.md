# 什么是 Actor？
在「[Actor 系统](actor-systems.md)」这一节中，我们介绍了 Actor 是如何形成层次结构的，以及其是构建应用程序的最小单元。本节将单独地研究 Actor，解释在实现它时遇到的概念。有关所有细节的更深入探讨，请参阅「[Actors](../actors/actors.md)」。

Hewitt、Bishop 和 Steiger 在 1973 年定义的[Actor 模型](https://en.wikipedia.org/wiki/Actor_model)是一种计算模型，它准确地表达了分布式计算的含义。处理单元（Actor）只能通过交换消息进行通信，并且在接收到消息后，Actor 可以执行以下三个基本操作：

1. 向它知道的 Actor 发送有限数量的消息
2. 创建有限数量的新 Actor
3. 指定要应用于下一条消息的行为

Actor 是[状态](#状态)、[行为](#行为)、[邮箱](#邮箱)、[子 Actor](#子 Actor) 和[监督者策略（`Supervisor Strategy`）](#监督者策略)的容器。所有这些都封装在一个 [Actor 引用](#Actor 引用)之后。一个值得注意的方面是，Actor 有一个明确的生命周期，当不再被引用时它们不会被自动销毁；生命周期在创建之后，你有责任确保它最终会被终止，这也让你能够控制[当 Actor 终止时](#当 Actor 终止)如何释放资源。

## Actor 引用
如下面详细介绍的，为了从 Actor 模型中获益，需要将 Actor 对象从外部屏蔽。因此，使用 Actor 引用将 Actor 表示为外部对象，这些引用是可以自由地传递且不受限制的对象。这种分为内部对象和外部对象的方法可以实现所有所需操作的透明性：在不需要更新其他地方引用的情况下即可重新启动 Actor，或将实际的 Actor 对象放在远程主机上，或在完全不同的应用程序中向 Actor 发送消息。但最重要的一点是，不可能查看 actor 的内部并从外部掌控其状态，除非actor不明智地发布此信息本身。

Actor 引用是参数化的，只能给他们发送指定类型的消息。

## 状态
Actor 对象通常包含一些反映 Actor 可能处于的状态的变量。这可以是一个显式状态机，也可以是一个计数器、一组监听器、待处理的请求等。这些数据使 Actor 变得有价值，并且必须保护他们免受其他 Actor 的损坏。好消息是，从概念上讲，Akka 的每个 Actor 都有自己的轻量级线程，这完全与系统的其他部分隔离开来。这意味着，不必使用锁来同步访问，你可以编写 Actor 代码，而不必担心并发性。

在幕后，Akka 将在一组真正的线程上运行一组 Actor，在这些线程中，通常许多 Actor 共享一个线程，随后对一个 Actor 的调用可能最终在不同的线程上进行处理。Akka 确保这个实现细节不会影响处理 Actor 状态的单个线程。

因为内部状态对 Actor 的操作至关重要，所以状态不一致是致命的。因此，当 Actor 失败并由其监督者重新启动时，将从头开始创建状态，就像第一次创建 Actor 时一样。这是为了使系统能够自我修复。

或者，可以通过持久化接收到的消息并在重新启动后重放它们，actor 的状态可以自动恢复到重启前的状态（参见[事件溯源](../typed/persistence.md)）。

## 行为
每次处理消息时，它都与 Actor 的当前行为相匹配。行为（`Behavior`）指的是一个函数，它定义了在该时间点对消息做出反应时要采取的操作，例如，如果客户端被授权，就转发一个请求，否则就拒绝它。这种行为可能会随着时间的推移而改变，例如，由于不同的客户端随着时间的推移而获得授权，或者因为 Actor 可能会进入“停止服务”模式，然后返回。这些更改是通过从行为逻辑中读取的状态变量中对它们进行编码来实现的，或者函数本身可以在运行时通过返回用于下一条消息的不同行为来换出。但是，在构造 Actor 对象期间定义的初始行为是特殊的，因为重新启动 Actor 会将其行为重置为初始行为。

消息可以被发送到一个[Actor 引用](#Actor 引用)，在这个外观后面有一个接收消息并对其采取行动的行为。 Actor 引用和行为之间的绑定会随着时间的推移而改变，但这在外部是不可见的。

Actor  引用是参数化的，只能给他们发送指定类型的消息。在创建Actor引用（及其actor）时，必须建立actor引用与其类型参数之间的关联。因此，每个行为也被参数化为它能够处理的消息类型。由于行为可以在actor引用外观后面改变，指定下一个行为是一个受约束的操作：后继者必须处理与其前任相同类型的消息。为了不使引用此 Actor 的 Actor 引用无效，这是必要的。

这使得无论何时向 Actor 发送消息，我们都可以静态地确保消息的类型是 Actor 声明要处理的类型——我们可以避免发送完全毫无意义的消息的错误。但是，我们无法静态确保当接收到我们的消息时，actor 引用背后的行为将处于给定状态。根本原因是actor引用和行为之间的关联是一个动态的运行时属性，编译器在翻译源代码时无法知道它。

这与具有内部变量的普通 Java 对象相同：在编译程序时，我们无法知道它们的值是什么，如果方法调用的结果取决于这些变量，那么结果在一定程度上是不确定的——我们只能确保返回的值是给定的类型。

Actor 命令的回复消息的类型由消息中包含的回复Actor引用的类型来描述。这将允许根据其类型来描述对话：回复将是类型 A，但它也可能包含类型 B 的地址，然后允许另一个Actor通过发送类型 B 的消息来继续对话这个新actor参考。虽然我们不能静态表达一个 Actor 的“当前”状态，但我们可以表达两个 Actor 之间协议的当前状态，因为这只是由接收或发送的最后一个消息类型给出的。

## 邮箱
Actor 的目的是处理消息，这些消息是从其他 Actor（或从 Actor 系统外部）发送给 Actor 的。连接发送方和接收方的部分是 Actor 的邮箱：每个 Actor 只有一个邮箱，所有发送方都将其消息排队。排队是按发送操作的时间顺序发生的，这意味着由于在线程间分发 Actor 的明显随机性，不同 Actor 发送的消息在运行时可能没有定义顺序。另一方面，从同一个 Actor 向同一个目标发送多条消息将以相同的顺序将它们排队。

有不同的邮箱实现可供选择，默认为`FIFO`：Actor 处理的消息的顺序与它们排队的顺序匹配。这通常是一个很好的默认值，但是应用程序可能需要将某些消息优先于其他消息。在这种情况下，优先级邮箱将不总是在末尾排队，而是在消息优先级指定的位置排队，甚至可能在前面。当使用这样的队列时，处理的消息的顺序将自然地由队列的算法定义，通常不是`FIFO`。

Akka 与其他一些 Actor 模型不同的一个重要特性是，当前behavior必须始终处理下一条出列的消息，而不是扫描邮箱以查找下一条匹配的消息。违背这一消息处理通常被视为失败，除非重写此行为，。

## 子 Actor
每个 Actor 都可能是一个监督者：如果它为分配子任务创建子 Actor，它将自动对它们进行监督。子列表在 Actor 的上下文中维护，并且 Actor 可以访问它。对列表的修改是通过生成（spawning）或停止（stopping）子项来完成的，并且这些操作会立即返回。实际的创建和终止操作以异步方式在后台发生，因此它们不会“阻塞”其监督者。

## 监督者策略
Actor 的最后一个部分是其处理子 Actor 异常的策略——故障。故障处理由 Akka 透明地完成，对每个故障对应[故障容错](../typed/fault-tlerance.md)种的一个策略描述。

## 当 Actor 终止
一旦一个 Actor 终止，即以一种不被重启处理的方式失败、自行停止或被其监督者停止，它将释放其资源，将其邮箱中的所有剩余邮件排入系统的“死信邮箱”，该邮箱将它们作为死信（`DeadLetters`）转发到事件流（`EventStream`）。然后在 Actor 引用中用系统邮箱替换原 Actor 的邮箱，将所有新消息作为死信重定向到事件流。但是，这是在尽最大努力的基础上完成的，因此不要依赖它来构建“有保证的消息传递”。

----------

[督和监测 ](supervision.md)

----------
**英文原文链接**：[What is an Actor?](https://doc.akka.io/docs/akka/current/general/actors.html).